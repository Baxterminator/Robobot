#!/usr/bin/python3
from typing import Tuple
import rclpy
from rclpy.node import Node
from raubase_msgs.srv import AskCameraImage
import cv2 as cv
import cv2.aruco as ArUco
import numpy as np
from cv_bridge.core import CvBridge
from sensor_msgs.msg import Image, CompressedImage
import requests


def toBGR(hex: str) -> np.ndarray:
    return np.array(list(int(hex[i : i + 2], 16) for i in (4, 2, 0)))


class ImageProcessor(Node):

    # Calibration coefficients and other constants
    camera_matrix = np.array(
        [[1050.6, 0.0, 712.6], [0.0, 1046.7, 430.6], [0.0, 0.0, 1.0]]
    )
    dist_coeffs = np.array([-0.397866, 0.173319, 9.58965e-05, -0.000660305, -0.0385043])

    KERNEL = np.ones((1, 1), np.uint8)
    BALL_RADIUS = 5
    CAMERA_SERVICE = "/camera/get_image"
    DEBUG_IMG = "/camera/debug_img"
    DEBUG_HSV = "/camera/ball_mask"
    DATA_OUTPUT = "/"

    USE_COMPRESSED = True

    # API credentials and endpoint
    API_URL = "https://detect.roboflow.com/testobjectdetection-rruyx/1"
    API_KEY = "9mWH7ZBZWjRiFIqNYfLd"

    def __init__(self) -> None:
        super().__init__("ImageProcessor")  # type: ignore
        self.timer = self.create_timer(0.5, self.request_image)
        self.rec = True

        self.client = self.create_client(
            AskCameraImage,
            ImageProcessor.CAMERA_SERVICE,
        )
        if ImageProcessor.USE_COMPRESSED:
            self.cimg_sub = self.create_subscription(
                CompressedImage,
                "/compressed",
                self.compressed_image_process,
                1,
            )
        else:
            self.img_sub = self.create_subscription(
                Image,
                "/camera",
                self.image_process,
                1,
            )

        self.img_req = AskCameraImage.Request()
        self.bridge = CvBridge()

        self._debug = (
            self.declare_parameter("debug", True).get_parameter_value().bool_value
        )
        self._rslt_img_pub = self.create_publisher(Image, ImageProcessor.DEBUG_IMG, 10)
        self._msk_img_pub = self.create_publisher(Image, ImageProcessor.DEBUG_HSV, 10)

        # OpenCV parameters
        self._lower_ball = toBGR(
            self.declare_parameter("lower_orange", "64640A")  # In RGB
            .get_parameter_value()
            .string_value
        )
        self._upper_ball = toBGR(
            self.declare_parameter("upper_orange", "FFFF14")  # In RGB
            .get_parameter_value()
            .string_value
        )
        self._aruco_detector = ArUco.ArucoDetector(
            ArUco.getPredefinedDictionary(ArUco.DICT_4X4_50),
            ArUco.DetectorParameters(),
        )

    def request_image(self):
        if not self.rec:
            return

        # Get image
        if not self.client.wait_for_service(1.0):
            self.get_logger().warn("Waiting for for camera service ...")
            return

        self.get_logger().info("Requesting image", throttle_duration_sec=1)
        self.rec = False
        self.client.call_async(self.img_req)

    def compressed_image_process(self, img: CompressedImage):
        self.get_logger().info("Received !")
        frame = self.bridge.compressed_imgmsg_to_cv2(img, desired_encoding="bgr8")
        self.process(frame)

    def image_process(self, img: Image):
        self.get_logger().info("Received !")
        # Process image
        frame = self.bridge.imgmsg_to_cv2(img, desired_encoding="bgr8")
        self.process(frame)

    def process(self, frame: cv.typing.MatLike) -> None:
        self.rec = True
        bx, by, br = self.detect_golf_ball(frame)
        cnrs, ids, rjcts = self.detect_aruco(frame)
        p = self.get_predictions(frame)
        self.detect_ball_from_predictions(
            frame, p, ImageProcessor.camera_matrix, ImageProcessor.dist_coeffs
        )

        print(p)

        if self._debug:
            self.get_logger().info("Sending debug !")
            # Draw golf ball
            if br >= 0:
                cv.circle(frame, (bx, by), br, (0, 255, 255))

            # ArUco
            if ids is not None:
                ArUco.drawDetectedMarkers(frame, cnrs, ids)
            ArUco.drawDetectedMarkers(frame, rjcts, None, (255, 255, 20))

            self._rslt_img_pub.publish(
                self.bridge.cv2_to_imgmsg(frame, encoding="bgr8")
            )

    def detect_golf_ball(self, frame: cv.typing.MatLike) -> Tuple[int, int, int]:
        """
        Detect a golf ball in the frame.

        Returns: (x, y, r) of the detected ball
            or   (-1,-1,-1) if no ball was detected
        """
        hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)
        mask = cv.dilate(
            cv.inRange(hsv, self._lower_ball, self._upper_ball),
            ImageProcessor.KERNEL,
            iterations=2,
        )

        # Send debug HSV mask
        if self._debug:
            self._msk_img_pub.publish(self.bridge.cv2_to_imgmsg(mask, encoding="8UC1"))

        contours, _ = cv.findContours(mask, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
        if contours:
            c = max(contours, key=cv.contourArea)
            (x, y), radius = cv.minEnclosingCircle(c)
            if radius > ImageProcessor.BALL_RADIUS:  # RADIUS OF THE BALL
                cv.circle(frame, (int(x), int(y)), int(radius), (0, 255, 0), 2)
                return (int(x), int(y), int(radius))
        return (-1, -1, -1)

    def detect_aruco(self, frame: cv.typing.MatLike):
        """
        Detect an ARuCo code in the frame"""
        gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
        return self._aruco_detector.detectMarkers(gray)

    def get_predictions(self, frame):
        _, img_encoded = cv.imencode(".jpg", frame)
        response = requests.post(
            ImageProcessor.API_URL,
            files={"file": img_encoded.tobytes()},
            headers={"Authorization": f"Bearer {ImageProcessor.API_KEY}"},
        )
        predictions = response.json().get("predictions", [])
        return predictions

    def detect_ball_from_predictions(
        self, frame, predictions, camera_matrix, dist_coeffs, real_ball_diameter_cm=4
    ):
        for pred in predictions:
            # Assuming 'red' is the class for the ball. Adjust if necessary.
            if pred["class"] == "red":
                x = int(pred["bbox"]["x"])
                y = int(pred["bbox"]["y"])
                width = int(pred["bbox"]["width"])
                height = int(pred["bbox"]["height"])

                # Calculate diameter in pixels as the average of width and height
                diameter_in_image_px = (width + height) / 2

                # Correct for camera distortion
                center_px = np.array(
                    [[[x + width / 2, y + height / 2]]], dtype=np.float32
                )
                undistorted_points = cv.undistortPoints(
                    center_px, camera_matrix, dist_coeffs
                )
                x_corrected, y_corrected = undistorted_points[0, 0, :]

                # Estimate the Z distance
                focal_length_px = (camera_matrix[0, 0] + camera_matrix[1, 1]) / 2
                Zc = (focal_length_px * real_ball_diameter_cm) / diameter_in_image_px

                # Estimate X and Y based on Z
                Xc = (x_corrected - camera_matrix[0, 2]) * Zc / camera_matrix[0, 0]
                Yc = (y_corrected - camera_matrix[1, 2]) * Zc / camera_matrix[1, 1]

                print(
                    f"Ball position in camera coordinates (cm): Xc={Xc}, Yc={Yc}, Zc={Zc}"
                )
                return (Xc, Yc, Zc)
        return None


# =============================================================================
# ROS Launching
# =============================================================================


def main(args=None):
    rclpy.init(args=args)

    proc = ImageProcessor()

    while rclpy.ok():
        rclpy.spin_once(proc)

    proc.destroy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    main()
